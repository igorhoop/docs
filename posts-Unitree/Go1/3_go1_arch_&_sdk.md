# Архитектура робота и SDK

> Данное руководство содержит информацию об аппаратном устройстве робота и о архитектуре взаимодействия компонентов его программного обеспечения. Также представлено введение в SDK робота: различия между низкоуровневым и высокоуровневым программированием движения, компиляция и запуск примеров. В руководстве используется робособака модели Go1, однако, информация будет актуальна и для других моделей производителя Unitree (с небольшими изменениями, о которых будет отдельно оговариваться). 

Руководство предназначено для технических специалистов. Потребуются навыки работы с сетью и командной строкой. Для запуска пройстеших примеров знание C++ является желательным, но не обязательным.


Подача материала выполнена не в строгой форме, а в виде урока. Формат обучения в виде повествования, интерактивного, чтобы у читателя возникло ощущение проводится диалог. 


## Введение
Итак, **Вы** или ваша компания приобрели робота компании Unitree. Вы уже ознакомились с [быстрым стартом](./2_go1_quick_start.html), научились ловко управлять роботом с пульта, а теперь задумались о том, что пришло время погрузиться немножко глубже. Давайте заварим чай, усядемся по удобнее и погрузимся в увлекательный внутренний мир робота. Нам понадбоится: патч-корд, монитор с HDMI-кабелем, клавиатура/мышь, возможно, USB-хаб.

## Аппаратное устройство
Если подвигать суставами робота, можно сделать вывод о том, что робот имеет 12 моторов. Все роботы-собаки будут иметь по 12 моторов, однако набор бортовых компьютеров у разных моделей будет отличаться (а соответственно и выведенные наружу коммуникационные интерфейсы). Собака модели Go1 оборудована 5-ю бортовыми компьютерами:

|Бортовой компьютер|Arch|IP-адрес|Доступ|Комментарий|
|-----|-----|-----|-----|-----|-----|
|Микроконтроллерная плата (на базе STM)|Arm|192.168.123.10|нет доступа|Управление движением на низком уровне|
|Raspberry Pi CM4|Arm|192.168.123.161, 192.168.12.1|HDMI, SSH: pi/123|Управление движением на высоком уровне, вебинтерфейс, раздача Wi-Fi|
|NVidia Jetson Nano|Arm|192.168.123.13|SSH: unitree/123|Вспомогательный, Машинное зрение, камеры головы, динамиком. Располагается в голове, физический доступ извне отсутствует|
|NVidia Jetson Nano|Arm|192.168.123.14|SSH: unitree/123|Машинное зрение, боковые камеры|
|NVidia Jetson Nano|Arm|192.168.123.15|SSH: unitree/123|Машинное зрение, нижняя камера|

Все компьютеры подключены по Ethernet в одну локальную сеть посредством встроенного хаба.
В случае если вы хотите подключиться к роботу через патч-корд, вы можете подключиться в эту сеть используя Ethernet-разъем на спине робота. Сетевой адаптер вашего ПК должен быть настроен на автоматическое подключение настроек. Установленный на Raspberry Pi DHCP-сервер присвоит вашему компьютеру IP-адрес в подсети 192.168.123.0/24. Теперь вы можете пинговать все эти хосты. 

Немного иная ситуация будет если вы решили подключиться к роботу по Wi-Fi. За раздачу Wi-Fi отвечает тоже Raspberry Pi, но на этот раз он выдаст вам IP-адрес в подсети 192.168.12.0/24 и настроит маршрутизацию. Благодаря ей вы все равно сможете видеть подсеть 192.168.123.0/24.


Давайте по порядку разберем назначение каждого бортового компьютера:

- **Микроконтроллерная плата** (192.168.123.13) находится внутри корпуса и выполняет следующий список работ: 
1. общение с моторами на низком уровне: передача управляющих команд и прием от моторов сообщений обратной связи (по интерфейсу RS-485).
2. общение с компьютером высокого уровня: прием команд от верхнего уровня, передача информационных сообщений на верхний уровень (по протоколу TCP/IP).
3. работа с радиотрансивером: прием управляющих радиосигналов с пульта управления

Подключиться и что-то изменить не получится, так как SSH не реализован в прошивке платы. Теоретически, если вскрыть робота и вытащить все бортовые компьютеры кроме этой платы, то роботом все равно можно будет управлять с пульта управления. Сигналы с пульта будут приходить на микроконтроллерную плату, которая в свою очередь будет обрабатывать их и управлять моторами. Однако, робот будет крайне неустойчив, словно пьяный. Это называется **стандартный режим**, о котором упоминалсь в Быстром старте. В стандартном режиме за управление движением отвечает только прошивка микроконтроллерной платы и не учавствует компьютер верхнего уровня. 

- **Raspberry Pi CM4** (192.168.123.161) установлен на несущую плату, которая имеет выводы наружу со спины. Вы можете подключить монитор и устройства ввода и увидеть знакомый многим интерфейс Raspberry Pi OS, или же подключиться по SSH. Этот бортовой компьютер в первую очередь выполняет роль того самого компьютера верхнего уровня, отвечающего за движение. Специальная запущенная программа (процесс **unitree\_legged\_sport**) принимает информационные сообщения от микроконтроллерной платы, в которых содержатся данные о нажатых клавишах пульта, выполняет расчеты и посылает управляющие сообщение обратно микроконтроллерной плате. В этом случае собака двигается более устойчиво и это называется **спортивный режим**. Процесс **unitree\_legged\_sport** является ключевым и мы еще вернемся к разговору о нем. 

- **NVidia Jetson Nano** (192.168.123.13) - бортовой компьютер, находящийся в голове. Физического доступа снаружи к нему нет, подключение возможно только по SSH. Данный компьютер является вспомогательным, можно использовать для машинного зрения, так же он отвечает за обработку изображений с камер головы. На нем можно найти SDK для управления светодиодами головы.

- **NVidia Jetson Nano** (192.168.123.14) - бортовой компьютер, находящийся в корпусе и имеющий выход наружу со спины. Вы можете подключить монитор и устройства ввода и увидеть интерфейс Ubuntu 18.04, или же подключиться по SSH. Лидар?
- **NVidia Jetson Nano** (192.168.123.15) - бортовой компьютер, находящийся в корпусе и имеющий выход наружу со спины. Вы можете подключить монитор и устройства ввода и увидеть интерфейс Ubuntu 18.04, или же подключиться по SSH. Лидар?



## Функционирующее программное обеспечение

Давайте представим, что происходит при включении робота. Бортовые компьютеры получают питание и начинают загрузку своих ОС. Raspberry Pi (192.168.123.161) по окончанию загрузки автоматически запускает процесс **unitree\_legged\_sport**, который является официальной программой движения от производителя. Процесс, запустившись, перехватывает управления на себя. Он получает от микроконтроллерной платы (192.168.123.10) информационные пакеты с данными: о положении моторов, нажатых на пульте управления клавишах, параметры IMU (инерциальная система наклона), далее производит расчеты и отправляет обратно управляющие пакеты. Микроконтроллерная плата, получая эти пакеты, преобразует их в прямые команды для моторов.

Таким образом микроконтроллерная плата (192.168.123.10) является исполнительным устройством и постоянно взаимодействует с Raspberry Pi (192.168.123.161), которая, на основе обратной связи, постоянно выполняет управленченскую функцию.

Описанное взаимодействие относится к **спортивному режиму**. Вы наблюдаете его постоянно когда включаете робота. Робот встает самостоятельно как раз в момент запуска службы **unitree\_legged\_sport** и теперь готов к управлению. Однако, если бы связи между микроконтроллерной платой и Raspberry Pi не было, или же, к примеру, Raspberry Pi просто отсуствовал (или вышел из строя), то микроконтроллерная плата (192.168.123.10) работала бы самостоятельно (**стандартный режим**). Попробуйте убить процесс **unitree\_legged\_sport**, только предварительно лучше положить робота на землю. Оставшись без внешнего управления, микроконтроллерная плата снова возьмет управление движением робота на себя, и скорее всего упадет при старте ходьбы. Не обязательно убивать процесс чтобы переключиться в стандартный режим, для переключения можно просто использовать комбинацию `L1 + L2 + Start (Отключение спортивного режима)`. 


```note
Чтобы отличать спортивный режим от стандартного без запуска ходьбы, нажимайте `L2 + A`, переключаясь в положения стоя/лежа. Будучи в стандартном режиме, у робота будет третье положение (полуприседа), в то время как у спортивного режима будет только два: лежа и стоя. 

Убедитесь, что вы осознали разницу между режимами и научились отличать их. Это понимание потребуется при использовании SDK.
```

После убийства процесса, можно предположить, что вернуть робота обратно в спортивный режим не получится. Однако процесс автоматически перезапускается (поддерживается включенным), поэтому вы снова сможете обнаружить его запущенным. При этом он уже не перехватит управление. Теперь даже будучи запущенным, процесс **unitree\_legged\_sport** не будет учавствовать в управлении, и робот будет оставаться в стандартном режиме. Ровно до тех пор, пока вы не нажмете комбинацию `L1 + Start (Переключение в спортивный режим)`. В этом случае микроконтроллерная плата отправит процессу **unitree\_legged\_sport** (работающему на Raspberry Pi) сообщение, с просьбой взять управление на себя.


Итак, давайте подытожим. Существует два абсолютно разных режима работы: либо микроконтроллерная плата (192.168.123.10) производит расчеты и управляет моторами самостоятельно, либо снимает с себя нагрузку по расчетам и делегирует эту работу верхнему уровню (Raspberry Pi, 192.168.123.161), при этом все равно продолжая управлять моторами самостоятельно.


Стоит отметить что встроенные скрипты демонстрации устойчивости (танцы, вставание на задние лапы), а также режимы бега и хождения по лестнице, являются частью программы _unitree\_legged\_sport_



## SDK

Производитель располагает свое программное обеспечение в домашней директории пользователя бортовых компьютеров, в каталоге Unitree. Основная часть ПО находится на Raspberry Pi. Давайте посмотрим содержимое каталога `/home/pi/Unitree`.
Здесь находятся два каталога:

```
/autostart   # готовое программное обеспечение от Unitree, запускаемое автоматически при загрузке
/sdk         # каталог с SDK.
```

Заглянем в `autostart`. Здесь располагаются различные компоненты ПО.

```
...
/sport_mode      # каталог, где лежит официальная программа управления движением **unitree\_legged\_sport**
/trigger_sport   # каталог с программой, автоматически включающей спорт-режим при включении робота
/WebMonitor      # файлы веб-интерфейса робота
...
```

Веб-интерфейс, на который мы попадаем при заходе из браузера по адресам `192.168.12.1` или `192.168.123.161`, располагается и разворачивается на Raspberry Pi. В каталоге `sport_mode` лежит исполняемый файл обсуждаемой нами программы управления движением. Однако, как вы уже могли заметить когда убивали процесс, при запуске (или перезапуске) она запускается, но находится в режиме ожидания и не перехватывает сразу управления на себя. Для переключения используется `trigger_sport`. Эта программа отрабатывает единожды при включении робота. Именно поэтому робот встает автоматически при включении. Если бы `trigger_sport` отсутствовал, то после включения робот продолжит лежать на земле и останется в **стандартном режиме** управления (несмотря на запущенный **unitree\_legged\_sport**). Попробуйте поэкспериментировать и переименовать `trigger_sport`, тогда он не запустится при запуске. Вы всегда сможете бы вручную включить спортивный режим вышеупомянутой комбинацией клавиш.

В каталоге `/autostart` имеются и другие компоненты ПО, однако их обзор не входит в это руководство.

Давайте познакомимся с SDK. 

Пройдем по пути:
`Unitree/sdk/unitree\_legged\_sdk/examples/`
Здесь можно видеты файлы примеров с использованием. Перед компиляцией важно отметить что примеры разделяются на 2 типа: 
- Программы для низкоуровневого управления (например, _example_torque.cpp_)
- Программы для высокоуровневого управления (например, _example_walk.cpp_)

Код примеров низкоуровневого управления при исполнении, генерирует и отправляет управляющие пакеты, предназначенные для микроконтроллерной платы (192.168.123.10). При изучении исходников мы можете даже обнаружить этот IP-адрес в виде символьной константы заданной посредством директивы #define. Код низкоуровневого управления оперирует понятиями, наподобии "провернуть мотор в определенное положение", "развить нужный момент" и т.д.

Код примеров высокоуровневого управления при управлении, генерирует и отправляет управляющие пакеты (уже другого типа), предназначенные для процесса unitree\_legged\_sport (что тоже работает на самом Raspberry Pi). При изучении исходников, вы можете обнаружить IP-адрес 192.168.123.161, указывающий назначение отправки пакетов. Процесс unitree\_legged\_sport будет принимать эти пакеты и является своего рода API. Код высокоуровневого управления оперирует понятиями, наподобии "идти вперед", "повернуть корпус", "лечь" и т.д. Получив такой пакет, процесс unitree\_legged\_sport уже сам разберет его на пакеты низкого уровня и отправит их микроконтроллерной плате.

Исходя из такой архитектуры взаимодействия ПО, делаем **важный вывод**:

```warning

- Программы с **низкоуровневым** управлением запускаются только когда робот находится в **стандартном** режиме.
- Программы с **высокоуровневым** управлением запускаются только когда робот находится в **спортивном** режиме.

Запуск программы с низкоуровневым управлением в момент работы робота в спортивном режиме приведет к конфликту управления: управляющие команды для микроконтроллерной платы будут поступать не только от вашей программы, но и от процесса unitree\_legged\_sport. Робот перейдет в аварийный режим, который будет сигнализироваться звуковым сигналом зуммера. В этом случае поскорее завершите программу.

Запуск программы с высокоуровневым управлением в момент работы робота в стандартном режиме приведет к бездействию робота: управляющие команды для процесса unitree\_legged\_sport будут игнорироваться, так как процесс в данное время не управляет движением.
```

Давайте скомпилируем один из примеров. Для автоматизации компиляции и сборки используется _cmake_
Создайте каталог _build_, войдите в него и выполните следующие команды:
```
cmake ..
make _example_torque_
```

В каталоге должен появиться исполняемый файл _example_torque_. Переведем робота в стандартный режим комбинацией `L1 + L2 + Start` и выполним запуск программы.

```
./example_torque
```

Робот провернет один из моторов, добившись определенного момента силы.


Давайте скомпилируем высокоуровневый пример управления.
```
cmake ..
make _example_walk_
```

Переведите робота в спортивный режим и выполните запуск программы:

```
./example_walk
```

Робот начнет демонстрационные движения (повороты корпуса, повороты на месте, ходьба). Изучив исходники вы можете по шаблону создать свои уникальные движения.


```note
Описание используемых классов и методов SDK выходят за рамки данного руководства.
```


<hr>


![](/assets/images/go1_app_1.jpg){: width="300px"}






