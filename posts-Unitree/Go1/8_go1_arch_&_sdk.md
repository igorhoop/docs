# Архитектура робота и введение в SDK

> Данное руководство содержит информацию об аппаратном устройстве робота и о архитектуре взаимодействия компонентов его программного обеспечения. Также представлено введение в SDK робота: различия между низкоуровневым и высокоуровневым программированием движения, компиляция и запуск примеров.

Руководство предназначено для технических специалистов. Потребуются навыки работы с сетью и командной строкой. Для запуска пройстеших примеров из SDK желательно знание C++, но это не является обязательным.


Подача материала выполнена не в строгой форме, а в виде урока с комфортным, последовательным повествованием. Урок основан на базе обучений, который проводит отдел робототехнических систем.


## Введение
Итак, Вы или Ваша компания приобрели робота компании Unitree, модели Go1. Вы уже ознакомились с [быстрым стартом](./2_go1_quick_start.html), научились ловко управлять роботом с пульта, а теперь задумались о том, что пришло время погрузиться немножко глубже. Давайте заварим чай, усядемся поудобнее и загляним внутрь в архитектуру робота. Нам понадобится: патч-корд, монитор с HDMI-кабелем (необязательно), клавиатура/мышь, и возможно, USB-хаб.

## Аппаратное устройство
Если подвигать суставами робота, можно сделать вывод о том, что робот имеет 12 моторов. Все роботы-собаки будут иметь по 12 моторов, однако набор бортовых компьютеров у разных моделей отличается. Собака модели Go1 оборудована 5-ю бортовыми компьютерами:

|Бортовой компьютер|Arch|IP-адрес|SSH-доступ (логин/пароль)|Назначение|
|-----|:-----:|:-----:|:-----:|-----|
|Микроконтроллерная плата (на базе STM32)|ARM|192.168.123.10| - |Управление движением на низком уровне|
|Raspberry Pi CM4|ARM|192.168.123.161, 192.168.12.1|pi/123|Управление движением на высоком уровне, вебинтерфейс, раздача Wi-Fi, и т.д|
|NVidia Jetson Nano|ARM|192.168.123.13|unitree/123|Вспомогательное: машинное зрение, камеры головы, динамик. Располагается в голове, выведенные наружу коммуникационные интерфейсы отсутствуют|
|NVidia Jetson Nano|ARM|192.168.123.14|unitree/123|Вспомогательное: машинное зрение, боковые камеры|
|NVidia Jetson Nano|ARM|192.168.123.15|unitree/123|Вспомогательное: машинное зрение, нижняя камера|

Все компьютеры подключены по Ethernet в одну локальную сеть посредством встроенного хаба. В случае, если вы хотите подключиться к роботу через патч-корд, используйте ethernet-разъем на спине робота. Сетевой адаптер вашего ПК должен быть настроен на автоматическое подключение настроек. Установленный на Raspberry Pi DHCP-сервер присвоит вашему компьютеру IP-адрес в подсети `192.168.123.0/24`. Теперь вы можете пинговать все вышеуказанные хосты.

Немного иная ситуация будет если вы решили подключиться к роботу по Wi-Fi. За раздачу Wi-Fi отвечает тоже Raspberry Pi, но на этот раз он выдаст вам IP-адрес в подсети `192.168.12.0/24` и настроит маршрутизацию. Благодаря ей вы все равно сможете видеть подсеть 192.168.123.0/24.


Давайте по порядку разберем назначение каждого бортового компьютера:

- **Микроконтроллерная плата** (192.168.123.13) находится внутри корпуса, не имеет выводов наружу и выполняет следующий перечень задач: 
1. общение с моторами на низком уровне (по интерфейсу RS-485): передача управляющих команд и прием от моторов сообщений обратной связи.
2. общение с компьютером высокого уровня (по протоколу TCP/IP): прием команд от верхнего уровня, передача информационных сообщений на верхний уровень.
3. работа с радиотрансивером: прием управляющих радиосигналов с пульта управления

Если вскрыть робота и вытащить все бортовые компьютеры кроме этой платы, то роботом все равно можно будет управлять с пульта управления. Сигналы с пульта управления по радиоканалу будут приходить на микроконтроллерную плату, которая в свою очередь будет обрабатывть их и управлять моторами. Однако, робот будет крайне неустойчив, словно пьяный. Это называется **стандартный режим**, о котором упоминалсь в [быстром старте](./2_go1_quick_start.html). В стандартном режиме за управление движением отвечает только прошивка микроконтроллерной платы и **не учавствует** компьютер верхнего уровня. 

- **Raspberry Pi CM4** (192.168.123.161) - бортовой компьютер для высокоуровневого управления движением. Установлен на несущую плату, имеющую выводы наружу со спины. Вы можете подключить монитор и увидеть знакомый многим интерфейс Raspberry Pi OS, или же подключиться по SSH. На этом компьютере выполняется специальный процесс `unitree_legged_sport`, который взаимодействует с микроконтроллерной платой: принимает от нее информационные пакеты, производит расчеты и посылает управляющие пакеты обратно. В этом случае собака двигается более устойчиво и это называется **спортивный режим**. Процесс `unitree_legged_sport` является ключевым и мы еще вернемся к разговору о нем. 

- **NVidia Jetson Nano** (192.168.123.13) - бортовой компьютер, находящийся в голове. Физического доступа снаружи к нему нет, подключение возможно только по SSH. Данный компьютер является вспомогательным, можно использовать для машинного зрения, так же он отвечает за обработку изображений с камер головы. На нем можно найти SDK для управления светодиодами головы и запускать звуки используя встроенный динамик.

- **NVidia Jetson Nano** (192.168.123.14) - бортовой компьютер, находящийся в корпусе и имеющий выход наружу со спины. Вы можете подключить монитор и устройства ввода и увидеть интерфейс Ubuntu 18.04, или же подключиться по SSH. Лидар?
- **NVidia Jetson Nano** (192.168.123.15) - бортовой компьютер, находящийся в корпусе и имеющий выход наружу со спины. Вы можете подключить монитор и устройства ввода и увидеть интерфейс Ubuntu 18.04, или же подключиться по SSH. Лидар?



## Функционирующее программное обеспечение

Давайте представим, что происходит при включении робота. Бортовые компьютеры получают питание и начинают загрузку своих ОС. **Raspberry Pi CM4** (192.168.123.161) по окончании загрузки автоматически запускает процесс `unitree_legged_sport`, который является официальной программой движения от производителя. Процесс, запустившись, перехватывает управления на себя. Он получает от **микроконтроллерной платы** (192.168.123.10) информационные пакеты с данными о: положении моторов, нажатых на пульте управления клавишах, параметрах IMU (инерциальной системы наклона), далее производит расчеты и отправляет обратно управляющие пакеты. Микроконтроллерная плата, получая эти пакеты, преобразует их в прямые команды для моторов.

Таким образом микроконтроллерная плата является исполнительным устройством и постоянно взаимодействует с Raspberry Pi CM4, которая, получая обратную связь, выполняет управленченскую функцию.

Описанное взаимодействие называется **спортивным режимом**. Вы наблюдаете его постоянно когда включаете робота. Робот встает самостоятельно как раз в момент запуска `unitree_legged_sport` и теперь готов к управлению. Однако, если бы связи между микроконтроллерной платой и Raspberry Pi CM4 не было, или же, к примеру, Raspberry Pi просто отсуствовал (или вышел из строя), то микроконтроллерная плата работала бы самостоятельно (**стандартный режим**). Попробуйте убить процесс `unitree_legged_sport`, только предварительно лучше положите робота на землю. Оставшись без внешнего управления, микроконтроллерная плата снова возьмет управление движением робота на себя, и скорее всего упадет при старте ходьбы. Не обязательно убивать процесс чтобы переключиться в стандартный режим, для переключения можно просто использовать комбинацию `L1 + L2 + Start (Отключение спортивного режима)`. 


```note
Чтобы отличать спортивный режим от стандартного без запуска ходьбы, нажимайте `L2 + A`, переключая положения стоя/лежа. Будучи в стандартном режиме, у робота будет третье положение (полуприсед), в то время как у спортивного режима будет только два: лежа и стоя. 

Убедитесь, что вы осознали разницу между режимами и научились отличать их. Это понимание потребуется при использовании SDK.
```

После убийства процесса, можно предположить, что вернуть робота обратно в спортивный режим не получится. Однако процесс автоматически перезапускается (поддерживается включенным), поэтому можете обнаружить его снова запущенным. При этом он уже не перехватит управление. Теперь даже будучи запущенным, процесс `unitree_legged_sport` не будет учавствовать в управлении, и робот будет оставаться в стандартном режиме. Ровно до тех пор, пока вы не нажмете комбинацию `L1 + Start (Переключение в спортивный режим)`. В этом случае микроконтроллерная плата отправит процессу `unitree_legged_sport` (работающему на Raspberry Pi CM4) сообщение, с просьбой взять управление на себя.


Итак, давайте подытожим. Существует два абсолютно разных режима работы: либо микроконтроллерная плата производит расчеты и управляет моторами самостоятельно, либо снимает с себя нагрузку по расчетам и делегирует эту работу верхнему уровню, при этом все равно продолжая управлять моторами самостоятельно.

Стоит отметить, что встроенные скрипты демонстрации устойчивости (танцы, вставание на задние лапы), а также режимы бега и хождения по лестнице, являются частью программы `unitree_legged_sport`.

<hr>

Имеются и другие модули программного обеспчения. Производитель располагает свое программное обеспечение в домашних директориях пользователей бортовых компьютеров, в каталоге `/Unitree`. Взглянем, что из компонентов ПО располагается на Raspberry Pi. Давайте посмотрим содержимое каталога `/home/pi/Unitree`:

```
/autostart   # готовое программное обеспечение от Unitree, запускаемое автоматически при загрузке
/sdk         # каталог с SDK.
```

Заглянем в `/autostart`. Здесь располагаются исполняемые компоненты ПО, запускаемые автоматически при включении робота:

```
...
...
/sport_mode      # каталог, где лежит официальная программа управления движением **unitree\_legged\_sport**
/trigger_sport   # каталог с программой, автоматически включающей спорт-режим при включении робота
/WebMonitor      # файлы веб-интерфейса робота
...
...
```

Одним из них является веб-интерфейс, на который мы попадаем при заходе из браузера по адресам `192.168.12.1` или `192.168.123.161`. В каталоге `/sport_mode` лежит исполняемый файл многократно упомянутой нами программы управления движением. Однако, как вы уже могли заметить когда убивали процесс, при запуске (или перезапуске) она запускается, но находится в режиме ожидания и не перехватывает сразу управления на себя. Для переключения используется `trigger_sport`. Эта программа отрабатывает единожды при включении робота. Именно поэтому робот встает автоматически при включении. Если бы `trigger_sport` отсутствовал, то после включения робот продолжит лежать на земле и останется в **стандартном режиме** управления (несмотря на запущенный `unitree_legged_sport`). Попробуйте поэкспериментировать и переименовать `trigger_sport`, тогда он не запустится при запуске. Вы всегда сможете бы вручную включить спортивный режим вышеупомянутой комбинацией клавиш.

В каталоге `/autostart` имеются и другие модули ПО, однако их обзор не входит в это руководство.



## Введение в SDK



Давайте познакомимся с SDK. 

Пройдем по пути:
`Unitree/sdk/unitree\_legged\_sdk/examples/`
Здесь можно видеты файлы примеров с использованием. Перед компиляцией важно отметить что примеры разделяются на 2 типа: 
- Программы для низкоуровневого управления (например, _example_torque.cpp_)
- Программы для высокоуровневого управления (например, _example_walk.cpp_)

Код примеров низкоуровневого управления при исполнении, генерирует и отправляет управляющие пакеты, предназначенные для микроконтроллерной платы (192.168.123.10). При изучении исходников мы можете даже обнаружить этот IP-адрес в виде символьной константы заданной посредством директивы #define. Код низкоуровневого управления оперирует понятиями, наподобии "провернуть мотор в определенное положение", "развить нужный момент" и т.д.

Код примеров высокоуровневого управления при управлении, генерирует и отправляет управляющие пакеты (уже другого типа), предназначенные для процесса unitree\_legged\_sport (что тоже работает на самом Raspberry Pi). При изучении исходников, вы можете обнаружить IP-адрес 192.168.123.161, указывающий назначение отправки пакетов. Процесс unitree\_legged\_sport будет принимать эти пакеты и является своего рода API. Код высокоуровневого управления оперирует понятиями, наподобии "идти вперед", "повернуть корпус", "лечь" и т.д. Получив такой пакет, процесс unitree\_legged\_sport уже сам разберет его на пакеты низкого уровня и отправит их микроконтроллерной плате.

Исходя из такой архитектуры взаимодействия ПО, делаем **важный вывод**:

```warning

- Программы с **низкоуровневым** управлением запускаются только когда робот находится в **стандартном** режиме.
- Программы с **высокоуровневым** управлением запускаются только когда робот находится в **спортивном** режиме.

Запуск программы с низкоуровневым управлением в момент работы робота в спортивном режиме приведет к конфликту управления: управляющие команды для микроконтроллерной платы будут поступать не только от вашей программы, но и от процесса unitree\_legged\_sport. Робот перейдет в аварийный режим, который будет сигнализироваться звуковым сигналом зуммера. В этом случае поскорее завершите программу.

Запуск программы с высокоуровневым управлением в момент работы робота в стандартном режиме приведет к бездействию робота: управляющие команды для процесса unitree\_legged\_sport будут игнорироваться, так как процесс в данное время не управляет движением.
```

Давайте скомпилируем один из примеров. Для автоматизации компиляции и сборки используется _cmake_
Создайте каталог _build_, войдите в него и выполните следующие команды:
```
cmake ..
make _example_torque_
```

В каталоге должен появиться исполняемый файл _example_torque_. Переведем робота в стандартный режим комбинацией `L1 + L2 + Start` и выполним запуск программы.

```
./example_torque
```

Робот провернет один из моторов, добившись определенного момента силы.


Давайте скомпилируем высокоуровневый пример управления.
```
cmake ..
make _example_walk_
```

Переведите робота в спортивный режим и выполните запуск программы:

```
./example_walk
```

Робот начнет демонстрационные движения (повороты корпуса, повороты на месте, ходьба). Изучив исходники вы можете по шаблону создать свои уникальные движения.


```note
Описание используемых классов и методов SDK выходят за рамки данного руководства.
```


<hr>


![](/assets/images/go1_app_1.jg){: width="300px"}






